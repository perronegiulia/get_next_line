    fd [1024] bytes
read(3, buf, 10);
read from the fd 3 into the buffer 10 per call to function.
when you recall the function, you ll get the next 10 chars.

we are gonna stock all the n chars string into a linked list in the Heap.

A função get_content é responsável por ler os dados do descritor de arquivo
fornecido (fd) e armazená-los em um buffer (content). Ela usa uma função
personalizada strdup_tilln (não fornecida no código) para duplicar o conteúdo do
buffer até encontrar um caractere de nova linha. Em seguida, utiliza uma função
strcpy_fromn (não fornecida) para remover a parte copiada do conteúdo. A
função continua lendo até encontrar um caractere de nova linha ou chegar ao
final do arquivo. Se chegar ao final do arquivo, ela define o primeiro caractere
de content como nulo. Se ocorrer um erro na leitura, a função retorna NULL. Caso
contrário, ela retorna o resultado concatenado.
A função get_next_line é projetada para ser usada como um utilitário de leitura
de linhas. Primeiro, ela verifica se o descritor de arquivo é válido. Se content
já contém alguns dados, ela obtém uma linha dele usando a função strdup_tilln e
atualiza content. Se encontrar um caractere de nova linha, ela retorna a linha.
Caso contrário, ela chama a função get_content para ler mais dados e
concatená-los com os dados lidos anteriormente. Por fim, ela retorna o resultado
concatenado.
No entanto, existem algumas considerações importantes e problemas com esse código:

O tamanho do buffer, BUFFER_SIZE, é usado para ler dados do descritor de arquivo, mas seu valor não é fornecido no trecho de código. Certifique-se de definir BUFFER_SIZE adequadamente antes de usar esse código.

Várias funções personalizadas, como strdup_tilln e strcpy_fromn, são usadas no código, mas suas implementações não são fornecidas. Você precisará definir essas funções para que o código funcione corretamente.

O código não lida adequadamente com erros, o que é crucial para aplicativos do mundo real. Ele não lida com os erros retornados pela função read nem verifica falhas na alocação de memória.

O uso de static char content[BUFFER_SIZE] torna content compartilhado entre chamadas diferentes de get_next_line. Isso pode levar a comportamentos inesperados em um ambiente multithread.

O código pressupõe que as linhas no arquivo são terminadas com um caractere de nova linha, o que nem sempre é o caso.

O código não lida com o caso em que o arquivo termina sem um caractere de nova linha. Isso significa que a última linha pode não ser retornada.

É essencial liberar qualquer memória alocada dinamicamente (por exemplo, com malloc) para evitar vazamentos de memória. O código libera res em caso de erro de leitura, mas aparentemente não libera outras áreas de memória alocadas dinamicamente.

O trecho de código está faltando partes críticas, como a definição de ft_strjoin e outras funções necessárias e a inclusão dos cabeçalhos requeridos.

Para usar esse código de maneira eficaz, você precisará fornecer as funções ausentes, lidar com erros e fazer melhorias necessárias para robustez e flexibilidade.
